# Kubernetes Component

> 쿠버네티스 이해하기

    쿠버네티스를 컨테이너 관리 도구라고 알고 있지만, 실제로 쿠버네티스는 컨테이너 오케스트레이션을 위한 솔루션이다. 
    
    오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 하는 서비스를 제공하는 것을 의미한다.

> 왜 하필 쿠버네티스인가?

    쿠버네티스 외에도 여러 컨테이너 오케스트레이션 솔루션이 존재한다. 그렇다면 왜 하필 쿠버네티스인가? 

    쿠버네티스는 초기에 설치 및 학습이 어렵지만 다양한 기능을 제공하고 안정적이며 확장성이 좋고 정보량도 많다. 그냥 좋음

> 쿠버네티스 구성방법

    쿠버네티스를 구성하는 방법은 크게 3가지이다.

    1. 퍼블릭 클라우드 업체에서 제공하는 관리형 쿠버네티스
       - EKS(Amazon Elastic Kubernetes)
       - AKS(Azure Kubernetes Services)
       - GKE(Google Kubernetes Engine)

    이 세가지는 구성이 이미 다 갖춰져 있고 마스터 노드를 클라우드 업체에서 관리하기 때문에 학습용으로는 적합하지 않다.

    2. 수세의 Rancher, 레드햇의 OpenShift와 같은 플랫폼에서 제공하는 설치형 쿠버네티스. 
    => 유료라 접근하기 어려움

    3. 사용하는 시스템에 쿠버네티스 클러스터를 자동으로 구성해주는 솔루션
        - kubeadm, kops(kubernetes Operations), KRIB(Kubernetes Rebar Integrated Bootstrap), kubespray가 있다.

        이 중에서는 kubeadm이 가장 널리 알려져 있고 사용자가 변경하기도 수월하고 온프레미스와 클라우드를 모두 지원하고 배우기도 쉽다.

    

> 쿠버네티스 구성 요소의 이름 생성 규칙

    쿠버네티스의 구성 요소는 동시에 여러 개가 존재하는 경우 중복된 이름을 피하려고 뒤에 해시(hash)코드가 삽입됩니다. 이때 해시 코드는 무작위 문자열로 생성됩니다.

    coredns에는 중간에 해시코드가 하나 더있는데 이는 레플리카셋을 무작위 문자열로 변형해 추가한 것입니다.

> 쿠버네티스 구성요소

    # 마스터 노드
    * kubectl
    => 쿠버네티스 클러스터에 명령을 내리는 역할을 합니다. 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없다. 하지만 통상적으로 API서버와 주로 통신하므로 여기서는 API서버가 위치한 마스터 노드에 구성했다.
    
    * API 서버
    => 쿠버네티스 클러스터의 중심 역할을 하는 통로이다. 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖의 요소들 또한 API서버를 중심에 두고 통신하므로 API서버의 역할이 매우 중요하다. 회사에 비유하면 모든 직원과 상황을 관리하고 목표를 설정하는 관리자이다.

    * etcd
    => 구성 요소들의 상태 값이 모두 저장되는 곳이다. 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 편하다. 실제로 etcd외의 다른 구성 요소는 상태 값을 관리하지 않는다. 그러므로 etcd의 정보만 백업돼 있다면 긴급한 장애 상황에서도 쿠버네티스 클러스터는 복구할 수 있다. 또한 etcd는 분산 저장이 가능한 key-value 저장소이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있다. 
    
    * 컨트롤러 매니저
    => 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리한다. 예를 들어 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니저에 속한 노드 컨트롤러에서 이루어진다. 다른 예로 레플리카셋 컨트롤러는 레플리카셋에 요청받은 파드 개수대로 파드를 생성한다. 뒤에 나오는 서비스와 파드를 연결하는 역할을 하는 엔드포인트 컨트롤러 또한 컨트롤러 매니저이다. 

    * 스케줄러
    => 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당한다. 스케줄러라는 이름에 걸맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리하는 역할을 담당한다.

    # 워커노드

    * kubelet
    => 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 한다.

    * 컨테이너 런타임
    => 파드를 이루는 컨테이너의 실행을 담당한다. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스이다. 

    * 파드
    => 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해 모인 단위이다. 즉, 웹서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있다. 여기서 중요한 것은 파드는 언제라도 죽을 수 있는 존재라는 점이다. 가상 머신은 언제라도 죽을 수 있다고 가정하고 디자인하지 않지만, 파드는 언제라도 죽을 수 있다고 가정하고 설계됐기 때문에 쿠버네티스는 여러 대안을 디자인했다. 

    # 선택 가능한 구성요소

    * 네트워크 플러그인
    => 쿠버네티스 클러스의 통신을 위해서 네트워크 플러그인을 선택하고 구성해야 한다. 네트워크 플러그인은 일반적으로 CNI로 구성하는데, 주로 사용하는 CNI는 캘리코, 플래널, 실리움, 큐브 라우터, 로마나, 위브넷, Canal이 있다.

    * CoreDNS
    => 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS서버이다. 쿠버네티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용한다. 실무에서 쿠버네티스 클러스터를 구성하여 사용할 때는 IP보다 도메인 네임을 편리하게 관리해 주는 CoreDNS를 사용하는 것이 일반적이다.


> CNI란?

    CNI(Container Network Interface, 컨테이너 네트워크 인터페이스)는 클라우드 네이티브 컴퓨팅 재단의 프로젝트로, 컨테이너의 네트워크 안정성과 확장성을 보장하기 위해 개발됐습니다. CNI에 사용할 수 있는 네트워크 플러그인은 다양한데, 구성 방식과 지원하는 기능, 성능이 각기 다르므로 사용 목적에 맞게 선택하면 된다. 예를 들어 Calico는 L3로 컨테이너 네트워크를 구성하고 Flannel은 L2로 컨테이너 네트워크를 구성한다. 또한 네트워크 프로토콜인 BGP와 VXLAN의 지원, ACL(Access Control List)지원 , 보안 기능 제공 등을 살펴보고 필요한 조건을 가지고 있는 네트워크 플러그인을 선택할 수 있어서 설계 유연성이 높다.

    

> Kubelet과 kubectl

    kubelet은 쿠버네티스에서 파드의 생성과 상태 관리 및 복구 등을 담당하는 매우 중요한 구성 요소이다. 따라서 kubelet에 문제가 생기면 파드가 정상적으로 관리되지 않는다. kubectl을 통해 API서버에 명령을 전달하고 API서버가 각 노드의 kubelet에 명령을 전달한다. 이때 kubelet이 제대로 작동안한다면 명령이 잘 전달되지 않는다. 


> kube-proxy
