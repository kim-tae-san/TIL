# Kubernetes Basic

> Pod 생성하는법

    * kubectl run 
    
    단일 파드 1개만 생성되고 관리된다.

    * kubectl create deployment
    
    디플로이먼트(deployment)라는 관리 그룹 내에서 파드가 생성된다. 비유를 들자면, run으로 생성한 파드는 초코파이 1개이고, create deployment로 생성된 파드는 초코파이 상자에 들어있는 초코파이 1개이다.


# Kubernetes Object

    쿠버네티스를 사용하는 관점에서 파드와 디플로이먼트는 스펙과 상태등의 값을 가지고 있다. 이러한 값을 가지고 있는 파드와 디플로이먼트를 개별 속성을 포함해 부르는 단위를 오브젝트라고 한다. 

> 기본 오브젝트

    * 파드: 쿠버네티스에서 실행되는 최소 단위, 즉 웹 서비스를 구동하는 데 필요한 최소 단위이다. 독립적인 공간과 사용 가능한 IP를 가지고 있다. 하나의 파드는 1개 이상의 컨테이너를 가지고 있기 때문에 여러 기능을 묶어 하나의 목적으로 사용할 수도 있다. 그러나 범용으로 사용할 때는 대부분 1개의 파드에 1개의 컨테이너를 적용한다.
    
    * 네임스페이스: 쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹이다. 여기서는 3가지 네임스페이스를 우선 사용한다. 특별히 지정하지 않으면 기본으로 할당되는 default, 쿠버네티스 시스템에서 사용되는 kube-system, 온프레미스에서 쿠버네티스를 사용할 경우 외부에서 쿠버네티스 클러스터 내부로 접속하게 도와주는 컨테이너들이 속해 있는 metallb-system이 있다.

    * 볼륨: 파드가 생성될 때 파드에서 사용할 수 있는 디렉토리를 제공한다. 기본적으로 파드는 영속되는 개념이 아니라 제공되는 디렉터리도 임시로 사용한다. 하지만 파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있다.

    * 서비스: 파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수 없다. 따라서 파드 접속을 안정적으로 유지하도록 서비스를 통해 내/외부로 연결된다. 그래서 서비스는 새로 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결 해준다. 쉽게 설명하면 쿠버네티스 외부에서 쿠버네티스 내부로 접속할 때 내부가 어떤 구조로 돼 있는지, 파드가 살았는지 죽었는지 신경 쓰지 않아도 이를 논리적으로 연결하는 것이 서비스이다. 기존 인프라에서 로드밸런서, 게이트웨이와 비슷한 역할을 한다. 

    * 디플로이먼트: 기본 오브젝트만으로도 쿠버네티스를 사용할 수 있다. 하지만 한계가 있어서 이를 좀 더 효율적으로 작동하도록 기능들을 조합하고 추가해 구현한 것이 디플로이먼트이다. 이외에도 데몬셋, 컨피그맵, 레플리카셋, PV, PVC, 스테이트풀셋 등이 있으며, 앞으로도 요구 사항에 따라 목적에 맞는 오브젝트들이 추가될 것이다. 쿠버네티스에서 가장 많이 쓰이는 디플로이먼트 오브젝트는 파드에 기반을 두고 있으며, 레플리카셋 오브젝트를 합쳐놓은 형태이다. 레플리카셋은 레플리케이션컨트롤러가 발전한 형태이다. 

> scale을 이용해 pod 늘리기

    kubectl scale deployment dpy-nginx --replicas=3

> spec을 지정해 오브젝트 생성하기

    spec 파일로 deployment를 만들때 replica의 수를 조정하고 만들 수 있음. 

> 만든 deployment 기존 replica 수를 변경하기 위한 apply

    apply로 생성하면 변경사항을 편하게 적용할 수 있다.

> Run과 Create와 Apply의 차이점

    Run의 경우는 파일 실행 및 변경이 불가능
    Create는 파일 실행이 가능함.
    Apply는 파일 실행 및 변경이 가능하지만 명령실행이 안됨. 

> 파드의 컨테이너 자동 복구 방법

    Deployment에 있는 파드의 경우는 컨테이너가 자동복구된다.

    replicas의 수를 지속적으로 확인하고 선언한 수대로 유지하도록 부족하면 파드를 새롭게 만들어낸다. 따라서 임의로 파드를 삭제하면 replicas가 삭제된 파드를 확인하고 파드의 총 개수를 지정한 개수로 맞추기 위해 새로운파드를 생성하는 것이다. 

    디플로이먼트에 속한 파드를 삭제하려면 상위 디플로이먼트를 삭제해야 파드가 삭제된다. 

    kubectl delete deployment echo-hname

> 노드 자원 보호하기 

    노드는 쿠버네티스 스케줄러에서 파드를 할당받고 처리하는 역할을 한다. 그런데 최근에 몇 차례 문제가 생긴 노드에 파드를 할당하면 문제가 생길 가능성이 높다. 하지만 어쩔수 없이 해당 노드를 사용해야 한다면 어떻게 할까? 이런 경우에는 영향도가 적은 파드를 할당해 일정 기간 사용하면서 모니터링 해야한다. 노드에 문제가 생기더라도 파드의 문제를 최소화해야한다. 하지만 쿠버네티스는 모든 노드에 균등하게 파드를 할당하려고 한다. 그렇다면 어떻게 문제가 생길 가능성이 있는 노드라는 것을 쿠버네티스에게 알려줄까?

    이때 쿠버네티스에는 cordon기능을 사용한다. cordon으로 노드를 어떻게 관리하나? 

    kubectl cordon w3-k8s << 이러면 워커3은 스케줄링을 받지 못하는 상황이 된다.


> 노드 유지보수하기

    kubectl drain 명령을 이용해서 유지보수할 노드를 파드가 없는 상태로 만든다. 해당 노드의 파드를 전부 삭제하고 다른곳에 임시생성 해 놓아 비우는 것이다.

    이때 cannot delete DaemonSet-managed Pods라는 오류가 뜨는데 해당 파드는 각 노드에 1개만 존재해서 drain으로는 삭제 할 수 없다. 

    그래서 kubectl drain ~~ --ignore-daemonsets 명령을 이용해서 무시하고 지워준다. 


> 파드 업데이트하고 복구하기

    kubectl rollout history는 기록된 히스토리를 확인할 수 있다.
    kubectl rollout status는 기록된 status를 확인할 수 있다. 

    kubectl get pods -o=custom-columns=NAME:.metadata.name,IP:.status.podIP,STATUS:.status.phase,NODE:.spec.nodeName


> 업데이트 실패 시 파드 복구하기

    kubectl describe deployment name
    이 명령을 통해 디플로이먼트의 내용을 알 수 있음.

    kubectl rollout undo deployment name
    이 명령을 통해 명령 실행을 취소할 수 있다.

    