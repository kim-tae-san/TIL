# A Simple Message

```protobuf
message Test1 {
  optional int32 a = 1;
}
```

    어플리케이션에서 Test1 메시지를 만든다고 하고, a를 150이라고 설정했다 하자.
    메시지는 직렬화 되어서 output stream으로 넘어갈 것이다. 이때의 encoded message를 보면 

    08 96 01

    이라고 나올것이다. 그러면 이게 작은 numeric인건 알겠는데 무슨 의미일까? 

# Base 128 Varints 

    위의 예시를 이해하기 위해 varints를 이해해야한다. Varints는 1이나 그보다 더 많은 바이트를 사용하여 integers를 serializing하는 메소드이다. 

    varints에서 마지막 바이트를 제외한 각 바이트는 MSB(Most Significant Bit) set를 가지고 있다. 이것은 아직 더 바이트가 올거라고 암시한다. 각 바이트에서 나머지 7비트는 각 바이트에서 표현할 숫자를 2의 보수의 형태로 보관한다. 

    예를 들면 1을 보자

    0000 0001

    1바이트로 표현할 수 있기 때문에 MSB가 설정되어있지 않다.

    300을 보면 조금 더 복잡하다.

    1010 1100 0000 0010

    1바이트로는 표현이 되지 않기 때문에 첫번째 바이트에서 MSB가 1로 설정되어있다. 다음 바이트가 남아있다는 의미이다. 각 나머지 바이트를 조합하면 표현하고자 하는 원래의 숫자를 찾을 수 있다.

     1010 1100 0000 0010
    → 010 1100  000 0010
    → 000 0010  010 1100
    → 000 0010 ++ 010 1100
    → 100101100
    → 256 + 32 + 8 + 4 = 300

# Message Structure

    Protocol Buffer Message는 key-value쌍의 값이다. binary version의 메시지는 키로써 필드 넘버만 사용하고 각 필드의 이름과 선언된 타입은 각 메시지 타입의 정의를 참고해서 디코딩이 완료된 후에 결정된다.

    메시지가 인코딩 되면, 키와 밸류들은 바이트 스트림에 이어진다. 메시지가 디코딩 되면 파서가 인지하지 못하는 필드는 스킵할 수 있다. 

    각 페어의 키로 되는 wire-format message는 두개의 밸류를 가지고 있는데 하나는 field number이고 거기에 해당 값의 길이를 찾기위한 충분한 정보를 제공하는 wire type이라는 값이 있다. 대부분의 언어 실행에서 이 키는 tag로서 참조된다.

    각 키는 streamed message에서 (field_number << 3) | wire_type로 표현된다. 

    08 을 보면 

    000 1000

    이전 3비트가 wire_type이고 바로 앞 비트의 1이 field_number 이므로 이 키는 Varint의 필드넘버 1을 의미한다.