# Go Channel

> Channel 이란?

    채널은 데이터를 주고 받는 통로 역할을 하는 자료구조이다. 채널에 데이터를 넣고 뽑아내는 형태로 사용하며 흔히 서로 다른 고루틴 사이에 통신을 위해 쓰인다. Go는 채널을 기본 자료형으로 제공한다. 따라서 다른 패키지나 라이브러리 없이 바로 사용할 수 있다.

 

    채널을 사용하기 위해서는 make 함수를 통해 미리 생성해야 한다. 생성시 chan 이라는 키워드와 함께 해당 채널에서 주고 받을 자료형을 정의한다. 예를 들어 정수(int)를 주고 받는 채널은 chan int, 문자열(string)을 주고 받는 채널은 chan string과 같이 선언한다. 또한 채널을 방향성을 가진다. 양방향으로 통신할 수 있는 양방향 채널이 있고, 데이터를 넣기만 하거나 빼기만 할 수 있는 단방향 채널이 있다. 양방향 채널은 두가지의 단방향 채널의 동작을 모두 수행할 수 있는데 굳이 단방향 채널을 따로 정의한 이유가 궁금할 것이다. 그 이유는 바로 채널을 통해 데이터를 전달할때의 방향을 확실히 보이게 함으로써 코드를 단순하고 알기 쉽게 하기 위함이다.

 

    채널을 사용할 때는 '<-' 연산자를 자주 사용한다. 이는 채널을 통해 데이터를 전달한다는 연산자이며, 채널에 데이터를 전송하거나 채널로부터 데이터를 받을 때 사용한다. 또한 앞에서 설명한 단방향 채널을 선언할 때 chan 키워드 앞, 혹은 뒤에 함께 사용하여 방향성을 나타내는데 사용된다.

```go
c1 := make(chan int) // 새 정수 채널 c1
var chan int c2 = c1 // 새 채널 변수 c2에 c1 할당
var chan<- int c3 = c1 // send 전용 채널 c3
var <-chan int c4 = c1 // receive 전용 채널 c4
```


> 채널 사용하기

    채널은 내부에서 수신자와 송신자가 서로 기다리는 속성을 가진다. 따라서 위의 예시처럼 WaitGroup이나 sleep이 없어도 main 함수가 종료되지 않는다. 장점처럼 느껴질 수 있겠지만 반대로 생각해보면 수신자가 데이터를 받을 때 까지 송신자는 채널에 묶여 있게 되므로 다른 동작을 못하게 된다는 단점이 될 수도 있다. 즉 송신 고루틴과 수신 고루틴이 동시에 보내고 받을 준비가 되어 있어야 올바르게 동작한다. 이러한 문제를 해결하기 위해 Go는 채널 버퍼링 기능을 제공한다.
    
    위와 같이 사용한 채널은 버퍼가 없는 채널(Unbuffered Channel)이다. 송신 고루틴이 데이터를 채널에 전송하면 수신 고루틴이 해당 데이터를 받을 때 까지 기다린다. 반면 버퍼가 있는 채널(Buffered Channel)은 채널에 버퍼 크기를 지정함으로써 버퍼가 가득 차기 전까지는 수신 고루틴이 준비되지 않아도 송신 고루틴이 채널에 미리 데이터를 전송할 수 있다. 수신 고루틴의 준비 여부와는 상관없이 동작하므로 송신 고루틴이 데이터를 전송하고 다른 일을 바로 수행할 수 있다는 장점이 있다.

    버퍼가 있는 채널이 언제나 좋다는 것은 아니다. 버퍼가 가득 찬 경우 송신 고루틴이 데이터를 전송한다면 에러가 발생하여 고루틴 동작이 멈춰버린다. 경우에 따라서는 치명적인 문제로 이어질 수도 있을 것이다. 따라서 처음에는 버퍼가 없는 채널로 최적화된 코드를 작성하되, 필요에 따라서 버퍼의 크기를 조절해주는 것이 좋다.